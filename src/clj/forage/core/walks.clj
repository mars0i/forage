;; (Code s/b independent of MASON and plot libs (e.g. Hanami, Vega-Lite).)


;; TODO split this into two namespaces, one for generating walks, and one
;; for examining them.
(ns forage.core.walks
    (:require [utils.math :as m]
              [utils.spiral :as spiral]
              [utils.random :as r]
              [forage.core.findfood :as ff]
              [fastmath.core :as fm]
              [clojure.core :as cc] ; for cc/<, cc/> (in find-in-seg), and cc/+ (with reduce).
              [ham-fisted.api :as hf]
              [ham-fisted.hlet :as hfl])
    (:import [clojure.lang IFn$DDO]))

(set! *warn-on-reflection* true)
(set! *unchecked-math* :warn-on-boxed)
(fm/use-primitive-operators)

;; NOTE Advantages of starting with mathematical vectors (direction,
;; length) pairs over coordinates (x, y location pairs) are:
;;   - It's easier to calculate overall length, since the second element
;;     of every pair is already a length.
;;   - It's easier to paste walks together to make composite walks.
;;     If you start with sequences of coordinates, you have to shift
;;     them all with the value of the last point in the previous walk
;;     in the sequence.  If you start from math-vectors, you can just
;;     concatenate the sequences of vectors for the different subwalks,
;;     and then create the coordinate pair sequences as you normally would.


;; Setting this to 1 gives us symmetry between the swapped and
;; unswapped coordinates.  Seems as if it would improve performance
;; slightly to have a higher value, since then the x,y swap operations
;; would happen less often.  However, benchmarking shows otherwise.
;; See steep-slope-inf-benchmarks.txt.  (That was from an early stage.
;; I haven't tried changing this value since I started optimizing in 
;; October 2023.)
(def ^:const +steep-slope-inf+ 
  "If a slope is greater than this value, the x and y coordinates will
  be swapped temporarily and then unswapped later.  This is a way to
  deal with both truly vertical slopes (slope = ##Inf) and slopes that are
  so close to vertical that moving through a line segment with this slope
  will be problematic.  It also sidesteps the problem of identifying slopes
  that are actually vertical, but don't appear so because of float slop."
  1.0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GENERATING RANDOM WALKS

(defn step-vector-fn
  "Returns a function of no arguments that returns a random mathematical 
  vector in the form of pair containing a direction dir, in radians, and a
  length len.  dir is uniformly distributed in [0,2pi) using PRNG instance 
  or distribution instance dir-dist, and length is distributed according to
  distribution instance len-dist.  If low and high arguments are given, the
  distribution is truncated so that lengths fall within [low, high].  (These
  vectors represent steps going from one \"stop\" to the next in a random walk.)
  Example use:
    (def rng (r/make-well19937))
    (def step-vecs (repeatedly 
                     (step-vector-fn rng (r/make-powerlaw rng 1 2) 1 100)))"
  ([dir-dist len-dist] (fn [] [(r/next-radian dir-dist)
                               (r/next-double len-dist)]))
  ([dir-dist len-dist low high]
   (fn [] [(r/next-radian dir-dist) (r/next-double len-dist low high)])))


(defn make-levy-vecs
  "Returns an infinite sequence of mathematical vectors generated by
  step-vector-rn representing a LÃ©vy walk with direction distribution
  dir-dist, and length distribution len-dist, minimum value low and
  maximum value high."
  [dir-dist len-dist low high]
  (repeatedly (step-vector-fn dir-dist len-dist low high)))


;; NOTE SEE test/forage/walks.clj for experiments and test of 
;; incremental-composite-vecs that were formerly below and above this
;; point.

;; NOTE: Another good way to generate a sequence of vectors is to
;; simply concatenate sequences of vectors generated some other way, as above.
;; This version runs a test on every step.  The might be useful to e.g.
;; test for something about a found target/foodspot.  But my general
;; strategy is to generate walks in a higher-level sense.
;; TODO remove labels arg?  See docstring.
(defn incremental-composite-vecs
  "Returns an infinite sequence of mathematical vectors.  vec-fns is a
  sequence of functions like those generated by step-vector-fn. switch-fns
  is a sequence of functions, each of which can determine, on each step,
  whether to shift cyclically from one step vector function to the next to
  generate the next vector.  Each switch function should return an element
  that's either: (A) a truthy element which both means \"continue with this
  step vector\" function, and contains data to be passed to the same switch
  function on the next iteration in order to help it decide then, or (B)
  nil or false, indicating that the next step vector function should be
  used to generate the next step.  Each switch function should accept two
  arguments: (1) the new step vec, and (2) data from the last application
  of the same switch function (or nil if the previous application used a
  different switch function).  [Example data as second arg of switch
  functions: (i) number of steps in subsequence, (ii) length of
  subsequence, or (iii) the entire subsequence.] labels argument is
  experimental.  Could be used to distinguish subwalks, but only if
  endpoints are duplicated.  SEE ALSO: composite-walk-stops."
  ([switch-fns vec-fns]
   (incremental-composite-vecs switch-fns vec-fns nil))
  ([switch-fns vec-fns labels]
  (letfn [(make-vecs [sw-fns v-fns labls sw-data] ; lazy-seq needs to recurse on fn not loop/recur
            (lazy-seq
              (let [fresh-vec ((first v-fns))
                    ;; TODO Can I get rid of the conditional and always append the label?:
                    new-vec (if labls
                              (conj (vec fresh-vec) (first labls)) ; add label to end of record
                              fresh-vec)]                           ; if available
                (cons new-vec
                      (if-let [new-sw-data ((first sw-fns) new-vec sw-data)] ; truthy means "keep using this vec fn"
                        (make-vecs sw-fns v-fns labls new-sw-data)
                        (make-vecs (next sw-fns) (next v-fns) (next labls) nil))))))]
    (make-vecs (cycle switch-fns) (cycle vec-fns) (cycle labels) nil))))

(defn switch-after-n-steps-fn
  "Generates a dist?fn for use with incremental-composite-vecs.  The returned function
  switches the vec-fn after n steps."
  [^long n]
  (fn [_ ^long step-count]
    (let [new-step-count (if step-count
                           (inc step-count)
                           (long 1))] ; if falsey, initialize count
      (if (>= new-step-count n)
        false
        new-step-count))))

(defn subst-init-dir
  "Given a sequence step-seq of step vectors, i.e. [direction length] pairs,
  return a sequence that's the same except that the direction of the first 
  vector has been replaced by init-dir."
  [init-dir step-seq]
  (let [firststep  (vec (first step-seq))
        othersteps (rest step-seq)
        newstep    (assoc firststep 0 init-dir)]
    (cons newstep othersteps)))

(defn vecs-upto-len
  "Given a desired total path length, and a sequence of step vectors,
  returns a sequence of step vectors (beginning from the front of the
  sequence) whose lengths sum to desired-total (or less if vecs is too
  short).  The lengths are made to sum to exactly desired-total by reducing
  the length in the last step vector.  This function is eager rather than
  lazy."
  [^double desired-total vecs]
  (loop [tot-len 0.0, out-vecs [], in-vecs vecs] ; init with 0.0 to avoid warn-on-reflection error
    (if (empty? in-vecs)
      out-vecs
      (if (< tot-len desired-total)
        (let [v (first in-vecs)
              ^double len (second v)]
          (recur (+ tot-len len)
                 (conj out-vecs v)
                 (rest in-vecs)))
        ;; The length is long enough; now trim any extra length:
        (let [overshoot (- tot-len desired-total)
              [old-dir ^double old-len] (last out-vecs)
              newlast [old-dir (- old-len overshoot)]]
          (conj (vec (butlast out-vecs)) newlast))))))

(comment ;; OLD VERSION:
(defn vecs-upto-len
  "Given a desired total path length, and a sequence of step vectors,
  returns a sequence of step vectors (beginning from the front of the
  sequence) whose lengths sum to at least desired-total.  By default, the
  lengths are made to sum to exactly desired-total by reducing the length
  in the last step vector.  Add ':trim false' or ':trim nil' to return a
  sequence with the last vector as it was in the input vecs sequence.
  This function is eager rather than lazy."
  [^double desired-total vecs & {trim :trim :or {trim true}}]
  (loop [tot-len 0.0, out-vecs [], in-vecs vecs] ; init with 0.0 to avoid warn-on-reflection error
    (if (empty? in-vecs)
      out-vecs
      (if (< tot-len desired-total)
        (let [[_ len :as v] (first in-vecs)]
          (recur (+ tot-len len)
                 (conj out-vecs v)
                 (rest in-vecs)))
        (if-not trim
          out-vecs
          (let [overshoot (- tot-len desired-total)
                [old-dir old-len] (last out-vecs)
                newlast [old-dir (- old-len overshoot)]]
            (conj (vec (butlast out-vecs)) newlast)))))))
)

;; Instead of the following, one could use 
;; (count (vecs-upto-len desired-total vecs))
;; This version is more efficient if you don't yet want to separate out 
;; the relevant vecs, but then you might have to trim the last element
;; later.  I might delete count-vecs-upto-len later.
(defn count-vecs-upto-len
  "Given a desired total path length, and a sequence of step vectors,
  returns the number of steps needed to sum lengths to at least 
  desired-total."
  [^double desired-total vecs]
  (reduce (fn [[^double tot-len ^long cnt] [_ ^double len]]
            (if (< tot-len desired-total)
              [(+ tot-len len) (inc cnt)]
              (reduced cnt)))
          [0 0]
          vecs))

(defn next-walk-stop
  "Given an initial point (or a mathematical vector) in the form of a
  coordinate pair, and a mathematical vector in the form of a direction
  in radians and a length, returns a new coordinate pair that's the result
  of adding the vector to the point.  (This is the next \"stop\" in a walk.)
  If provided, an optional label is the third element of the returneed 
  Clojure vector."
  [[^double prevx ^double prevy] [dir len label]]
  (let [[^double vecx ^double vecy] (m/rotate dir [len, 0]) ; rotate vector lying on x-axis
        nextx (+ prevx vecx)  ; add vector to prev point
        nexty (+ prevy vecy)
        newpt [nextx nexty]]
    (if label (conj newpt label) newpt)))

;; I see no straightforward way to do this with reduce, btw.
(defn walk-stops
  "Generates a sequence of next points from an initial point (a coordinate
  pair) and a (finite) sequence of [direction, length] (mathematical) vectors,
  using each in turn, adding it to the previous point.  (The resulting points
  are the \"stops\" in a random walk.) Example use, where step-vecs has been 
  generated by repeated calls to next-walk-fn: (walk-stops [0 0] step-vecs)"
  [base-pt step-vectors]
  (loop [result [base-pt]
         prev-pt base-pt
         vectors (seq step-vectors)]
    (if vectors
      (let [next-pt (next-walk-stop prev-pt (first vectors))]
        (recur (conj result next-pt)
               next-pt
               (next vectors))) ; next turns empty sequences into nil
      result)))


(defn vecs-path-len
  "Calculate the length of a path specified by a sequence of vector representations
  in the form of [direction, length] pairs."
  [step-vectors]
  (reduce cc/+ (map second step-vectors)))

(defn stops-path-len
  "Calculate the length of a path specified by a sequence of stops, i.e. [x y] 
  coordinate pairs representing endpoints of connected line segments."
  [stops]
  (reduce cc/+
          (map m/distance-2D stops (rest stops))))


(defn composite-walk-stops
  "Pastes together the sequences of walk stops, i.e. sequences of location
  coordinate pairs, realizing all of the sequences if they have not been
  realized.  The sequences must be finite."
  [walk-stops-seqs]
  (doall (apply concat (map doall walk-stops-seqs))))

;; NOTE SEE test/forage/walks.clj for experiments and test of 
;; incremental-composite-vecs that were formerly at this point.

(defn shift-beyond-radius
  "Given a pair of coordinates from a foodspot, center, starting point, etc.,
  moves pad-dist away from in it a random direction using dir-dist as the 
  random direction generator."
  [dir-dist pad-dist coords]
  (let [dir (r/next-radian dir-dist)]
    (next-walk-stop coords [dir pad-dist])))


;; TODO: DOES THIS WORK: IS THE STATE THE SAME AT THE END?
(defn levy-foodwalk-flush-state
  "Uses up PRNG state like levy-foodwalk would, but without going through 
  the steps needed to find food.  The only required arguments are dir-dist,
  len-dist, and trunclen; or rng, trunclen, scale, and exponent. Returns nil.
  See levy-foodwalk for the meaning of parameters."
  ([look-fn look-eps maxpathlen init-dir trunclen rng scale exponent init-pad init-loc]
   (let [len-dist (r/make-powerlaw rng scale exponent)]
     (levy-foodwalk-flush-state look-fn look-eps maxpathlen init-dir trunclen rng len-dist init-pad init-loc)))
  ([look-fn look-eps maxpathlen init-dir trunclen dir-dist len-dist init-pad init-loc]
   (levy-foodwalk-flush-state dir-dist len-dist trunclen))
  ([rng trunclen scale exponent]
   (let [len-dist (r/make-powerlaw rng scale exponent)]
     (levy-foodwalk-flush-state rng len-dist trunclen)))
  ([dir-dist len-dist trunclen]
   (let [_ (repeatedly (step-vector-fn dir-dist len-dist 1 trunclen))]
     nil)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DEPRECATED BACKWARD-COMPATIBLE INDIRECTION TO FUNCTIONS IN NAMESPACE find.
;; These functions have been moved to ns find but I


;; See doc/xyshifts.md for detailed notes about this function and find-in-seg.
(defn xy-shifts
  [^double eps ^double slope]
   (println "DEPRECATED: Use version in namespace find.")
   (xy-shifts eps slope))

;; VERSION BASED ON branch cnuerber-main
;; TODO replace some of the agets with new ham-fisted structred let
(defn find-in-seg
  [look-fn eps x1 y1 x2 y2]
   (println "DEPRECATED: Use version in namespace find.")
  (find-in-seg look-fn eps x1 y1 x2 y2))

(defn path-with-food
  "Returns a vector containing first, found foodspots or nil, and second
  the sequence up to and including the location from which foodspots were
  found, or the entire sequence.  More specifically, given a sequence of
  stops (coordinate pairs) representing a random walk, and a small eps
  length, starts at [x1 y1] and uses seg-exam-fn [default: find-in-seg] to
  incrementally check each line segment defined by pairs of stops to see
  whether look-fn returns a truthy value, meaning that foodspots were
  found.  The sequence stops must contain at least two coordinate pairs.
  If foodspots are found, returns a pair vector containing: first, the
  foodspot information returned by look-fn, and second, a truncated
  sequence of stops in which the last element is the point from which the
  food was seen, and remaining points have been removed. If no food found
  in the entire sequence, a pair vector containing nil and the unchanged
  sequence is returned.  For backward compatibility, if seg-exam-fn is not
  passed, walks/find-in-seg is used as its default value."
  ([look-fn eps stops]
   (path-with-food find-in-seg look-fn eps stops))
  ([seg-exam-fn look-fn eps stops]
   (println "DEPRECATED: Use version in namespace find.")
   (path-with-food seg-exam-fn look-fn eps stops)))

(defn trim-full-walk
  "Gvien a foodwalk triple of the kind returned by foodwalk, levy-foodwalk,
  or straight-foodwalk, returns a similar triple in which the third
  element, full-walk, has been truncated at the front to include only those
  line segments not included in walk-until-food. That is, if no food was
  found, the current function will return a triple [nil, the full walk,
  nil]. If food was found, then walk-until-food contains the walk only up
  to the point that food was found.  The current function will then return
  a triple [collection containing foodspots, the walk up until the food was
  found, the rest of the walk]. Specifically: If no food was found,
  full-walk is replaced by nil since walk-until-food is identical to
  full-walk. If food was found, let n be the number of points in
  walk-until-food; Then the first n-1 points are dropped from full-walk in
  the return triple.  The last point in walk-until-food is the point from
  which food was found, which is usually not included in full-walk. Backing
  up by one means that full-walk includes full line segment from within
  which the food was found, partially.  The original full-walk can be
  reconstructed e.g. by removing the last element (the point from which the
  food was found--not the endpoint of the segment) from walk-until-food and
  then concatenating the two sequences."
  [[found walk-until-food full-walk]]
  (println "DEPRECATED: Use version in namespace find.")
  (trim-full-walk [found walk-until-food full-walk]))

(defn foodwalk
  "Given stop-walk, a representation of a possible walk as a sequence of
  location coordinate pairs, returns a triple produced by trim-full-walk.
  That is, returns a vector triple containing (a) a sequence of found
  foodspots or nil if none found, (b) the generated sequence from start
  until the point from which the foodspots were found or the entire
  sequence if no foodspots were found, and (c) a subsequence containing the
  remaining stops, if any, after the foodspots were found.  seg-exam-fn
  [default: forage.core.walks/find-in-seg] should apply look-fn to each
  segment defined by stop-walk, in order to determine whether it passes
  within perceptual radius of a foodspot."
  ([look-fn look-eps stop-walk]
   (foodwalk find-in-seg look-fn look-eps stop-walk))
  ([seg-exam-fn look-fn look-eps stop-walk]
  (println "DEPRECATED: Use version in namespace find.")
  (foodwalk seg-exam-fn look-fn look-eps stop-walk)))

(defn levy-foodwalk
  "Generates a random foodwalk starting from point init-loc in direction
  init-dir, and returns a vector triple containing (a) a sequence of found
  foodspots or nil if none found, (b) the generated sequence from start until
  the point from which the foodspots were found or the entire sequence if
  no foodspots were found, and (c) a subsequence containing the remaining
  stops, if any, after the foodspots were found.  If init-dir is falsey, 
  the initial direction will be random.  More specifically, the generated 
  foodwalk consists of a series of line segments and ends where a foodspot
  is first found, or when the sum of segment lengths is equal to maxpathlen.
  Food search uses look-fn to repeatedly check for food at points that are
  look-eps apart, beginning from init-loc. (The environment is to be wrapped
  up in look-fn and carried with it.)"
  ([look-fn look-eps maxpathlen init-dir trunclen rng scale exponent init-pad init-loc]
   (let [len-dist (r/make-powerlaw rng scale exponent)]
     (levy-foodwalk look-fn look-eps maxpathlen init-dir trunclen rng len-dist init-pad init-loc)))
  ([look-fn look-eps maxpathlen init-dir trunclen dir-dist len-dist init-pad init-loc]
   (println "DEPRECATED: Use version in namespace find.")
   (levy-foodwalk look-fn look-eps maxpathlen init-dir trunclen dir-dist len-dist init-pad init-loc)))

(defn straight-foodwalk
  "Generates a straight foodwalk starting from point init-loc in direction
  init-dir, and returns a vector triple containing (a) a sequence of found
  foodspots or nil if none found, (b) the generated sequence from start until
  the point from which the foodspots were found, and (c) the entire generated
  sequence including the stops after the foodspots were found.  More
  specifically, the foodwalk consists of a single line segment, which ends 
  where a foodspot is found or when maxpathlen is reached.  Food search uses
  look-fn to repeatedly check for food at points that are look-eps apart,
  beginning from init-loc."
  ([look-fn look-eps maxpathlen dir-dist init-pad init-loc init-dir]
   (println "DEPRECATED: Use version in namespace find.")
   (straight-foodwalk look-fn look-eps maxpathlen dir-dist init-pad init-loc init-dir))
  ([look-fn look-eps maxpathlen init-loc init-dir]
   (println "DEPRECATED: Use version in namespace find.")
   (straight-foodwalk look-fn look-eps maxpathlen init-loc init-dir)))

(defn path-until-found-length
  "Given a pair consisting of a possibly empty sequence of found foodspots and a
  path of walk stops until they were found (if they were), returns the length
  of the path.  If the argument is a sequence with more than two elements, its
  remaining elements are silently ignored."
  [[found-foodspots path-until-found]]
  (println "DEPRECATED: Use version in namespace find.")
  (path-until-found-length [found-foodspots path-until-found]))

;; Note nils are converted to empty cells by write-csv.
(defn path-if-found-length
  "Given a pair consisting of a possibly empty sequence of found foodspots and a
  path of walk stops until they were found (if they were), returns the length
  of the path, or nil if no foodspots were found.  If the argument is a sequence 
  with more than two elements, its remaining elements are silently ignored."
  [[found-foodspots path-until-found]]
  (println "DEPRECATED: Use version in namespace find.")
  (path-if-found-length [found-foodspots path-until-found]))

(defn count-successful
  "Returns the number of foodwalks that found any food."
  [foodwalks]
  (println "DEPRECATED: Use version in namespace find.")
  (count-successful foodwalks))

(defn count-found-foodspots
  "Returns the number of foodspots found by the foodwalks.  If it's
  possible for a foodwalk to find multiple foodspots, they'll be counted."
  [foodwalks]
  (println "DEPRECATED: Use version in namespace find.")
  (count-found-foodspots foodwalks))

(defn count-segments-until-found
  "Count segments in a foodwalk until food is found."
  ^long [fw]
  (println "DEPRECATED: Use version in namespace find.")
  (count-segments-until-found fw))

(defn count-segments-until-found-in-foodwalks
  "Sums results of count-segments-until-found in multiple foodwalks fws."
  [fws]
  (println "DEPRECATED: Use version in namespace find.")
  (count-segments-until-found-in-foodwalks fws))

(defn count-all-segments
  "Count all segments in a foodwalk, including the couldve segments after 
  found foodspots."
  ^long [fw]
  (println "DEPRECATED: Use version in namespace find.")
  (count-all-segments fw))

(defn count-all-segments-in-foodwalks
  "Sums results of count-all-segments in multiple foodwalks fws."
  [fws]
  (count-all-segments-in-foodwalks fws))

(defn sort-foodwalks
  "Sorts a sequence of foodwalks so that walks in which food 
  is found are first."
  [fws]
  (println "DEPRECATED: Use version in namespace find.")
  (sort-foodwalks fws))


(fm/unuse-primitive-operators) ; needed when I upgrade to Clojure 1.12
